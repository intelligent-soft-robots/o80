// Copyright (c) 2019 Max Planck Gesellschaft
// Author : Vincent Berenz

#pragma once

#include "back_end.hpp"
#include "o80/burster.hpp"
#include "o80/frequency_manager.hpp"
#include "o80/internal/standalone_runner.hpp"
#include "o80/observation.hpp"
#include "o80/time.hpp"
#include "observation.hpp"
#include "robot_interfaces/robot_backend.hpp"
#include "robot_interfaces/robot_data.hpp"
#include "robot_interfaces/robot_driver.hpp"
#include "robot_interfaces/robot_frontend.hpp"
#include "synchronizer/leader.hpp"
#include "time.hpp"

namespace o80
{

  /**
   * ! if an instance of Standalone of the related segment_id is 
   *   running, will send a stop request to this standalone.
   */
void please_stop(std::string segment_id)
{
    shared_memory::set<bool>(segment_id, "should_stop", true);
    try
    {
        synchronizer::Leader leader(segment_id + "_synchronizer");
        leader.pulse();
    }
    catch (...)
    {
    }
}

/**
 * ! A Standalone encapsulates and organize the 
 *   the communication between a (robot_interfaces) driver, a 
 *   (robot_interfaces) frontend, a (robot_interfaces) backend and
 *   a (o80) backend : at each iteration, information about the current state of 
 *   the robot actuators are passed by the frontend to the backend,
 *   which passes to the driver desired states values.
 *   @tparam QUEUE_SIZE number of commands that can be hosted
 *                      in the command queue at any point of time.
 *                      Exceptions will be
 *                     thrown if more commands are queued.
 *   @tparam NB_ACTUATORS number of actuators of the robot
 *   @tparam RI_ACTION template to the (robot_interfaces) frontend
 *   @tparam RI_OBSERVATION template to the (robot_interfaces) frontend
 *   @tparam o80_STATE template to the (o80) BackEnd
 *   @tparam EXTENDED_STATE class encapsulating supplementary arbitrary information 
 *                          (i.e. supplementary to the current actuators state)
 *                          that will be sent from the (robot_interfaces) frontend 
 *                          to the backend (which
 *                          will add these information to the observations)
 */
template <int QUEUE_SIZE,
          int NB_ACTUATORS,
          class RI_ACTION,
          class RI_OBSERVATION,
          class o80_STATE,
          class o80_EXTENDED_STATE>
class Standalone
{
public:
    static constexpr int queue_size = QUEUE_SIZE;
    static constexpr int nb_actuators = NB_ACTUATORS;

    typedef RI_ACTION RiAction;
    typedef RI_OBSERVATION RiObservation;
    typedef o80_STATE o80State;
    typedef o80_EXTENDED_STATE o80ExtendedState;

private:
    typedef robot_interfaces::SingleProcessRobotData<RI_ACTION, RI_OBSERVATION>

        RiData;
    typedef std::shared_ptr<RiData> RiDataPtr;
    typedef robot_interfaces::RobotBackend<RI_ACTION, RI_OBSERVATION> RiBackend;
    typedef std::shared_ptr<RiBackend> RiBackendPtr;
    typedef robot_interfaces::RobotFrontend<RI_ACTION, RI_OBSERVATION>
        RiFrontend;
    typedef robot_interfaces::RobotDriver<RI_ACTION, RI_OBSERVATION> RiDriver;
    typedef std::shared_ptr<RiDriver> RiDriverPtr;
    typedef o80::
        BackEnd<QUEUE_SIZE, NB_ACTUATORS, o80_STATE, o80_EXTENDED_STATE>
            o80Backend;

public:
    /**
     * Creates instances of:
     * - (robot_interfaces) backend
     * - (robot interfaces) frontend
     * - (o80) BackEnd
     * @param ri_driver robot_interfaces robot driver
     * @param frequency desired frequency
     * @param segment_id shared memory segment id for o80 BackEnd.
     */
    Standalone(RiDriverPtr ri_driver_ptr,
               double frequency,
               std::string segment_id);

    ~Standalone();

    /**
     * ! Starts the robot interfaces backend
     */
    void start();

    /**
     * ! Stops the robot interfaces backend
     */
    void stop();

    /**
     * ! - If bursting is false, performs one iteration and then wait for the time
     *     requied to match the desired frequency.
     *   - If bursting is true, hang until the o80
     *     FrontEnd calls "burst".
     *
     */
    bool spin(bool bursting = false);

    /**
     * ! Similar to spin, and the extended state is added to the observation
     *   that is written to the shared memory by the o80 BackEnd.
     *
     */
    bool spin(o80_EXTENDED_STATE& extended_state, bool bursting = false);

    /**
     * ! user code to convert the observation read from robot_interfaces frontend 
     *   into the current o80 States.
     */
    virtual o80::States<NB_ACTUATORS, o80_STATE> convert(
        const RI_OBSERVATION& observation) = 0;

    /**
     * ! user code to convert the desired states generated by the o80 BackEnd
     *   into action required by the robot_interfaces frontend.
     */
    virtual RI_ACTION convert(
        const o80::States<NB_ACTUATORS, o80_STATE>& states) = 0;

    /**
     * ! converts the observation as returned by the robot_interfaces
     *   frontend into the o80 extended state.
     */
    virtual void enrich_extended_state(o80_EXTENDED_STATE& extended_state,
                                       const RI_OBSERVATION& observation) = 0;

private:
    bool iterate(const TimePoint& time_now, o80_EXTENDED_STATE& extended_state);

private:
    double frequency_;
    Microseconds period_;
    FrequencyManager frequency_manager_;
    TimePoint now_;
    std::shared_ptr<Burster> burster_;
    std::string segment_id_;
    RiDriverPtr ri_driver_ptr_;
    RiDataPtr ri_data_ptr_;
    RiFrontend ri_frontend_;
    RiBackend* ri_backend_ptr_;
    o80Backend o8o_backend_;
};

template <class RobotDriver, class o80Standalone, typename... Args>
void start_action_timed_standalone(std::string segment_id,
                                   double frequency,
                                   bool bursting,
                                   Args&&... args);


/**
 * @brief instantiates instances of (robot_interfaces) RobotDriver 
 * and of (o80) Standalone,
 * and starts them in a thread. A runtime exception is thrown
 * if another standalone of the same segment_id has already
 * been started.
 * tparam Args template arguments of the driver
 * param segment id o80 BackEnd segment id
 * param frequency frequency at which the standalone will iterate
 *       (non bursting mode)
 * param bursting if true, will run in bursting mode, i.e. 
 *                the standalone will iterate only when the o80
 *                frontend calls its burst function.
 * param args arguments for the driver
 */
template <class RobotDriver, class o80Standalone, typename... Args>
void start_standalone(std::string segment_id,
                      double frequency,
                      bool bursting,
                      Args&&... args);

/**
 * ! Stop the standalone of the specified segment_id.
 *   A runtime error is thrown if no such standalone is running.
 */
void stop_standalone(std::string segment_id);

/**
 * ! Returns true if the standalone is iterating.
 *   (returns also false if the standalone does not exist)
 */
bool standalone_is_running(std::string segment_id);

#include "standalone.hxx"
}
